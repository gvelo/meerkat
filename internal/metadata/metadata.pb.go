// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: metadata.proto

package metadata

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	storage "meerkat/internal/storage"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NodeIdList struct {
	NodeId [][]byte `protobuf:"bytes,1,rep,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *NodeIdList) Reset()         { *m = NodeIdList{} }
func (m *NodeIdList) String() string { return proto.CompactTextString(m) }
func (*NodeIdList) ProtoMessage()    {}
func (*NodeIdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{0}
}
func (m *NodeIdList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeIdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeIdList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeIdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeIdList.Merge(m, src)
}
func (m *NodeIdList) XXX_Size() int {
	return m.Size()
}
func (m *NodeIdList) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeIdList.DiscardUnknown(m)
}

var xxx_messageInfo_NodeIdList proto.InternalMessageInfo

func (m *NodeIdList) GetNodeId() [][]byte {
	if m != nil {
		return m.NodeId
	}
	return nil
}

type UpdateRootOP struct {
	DatabaseIngestionAliases map[string]string `protobuf:"bytes,1,rep,name=database_ingestion_aliases,json=databaseIngestionAliases,proto3" json:"database_ingestion_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DatabaseQueryAliases     map[string]string `protobuf:"bytes,2,rep,name=database_query_aliases,json=databaseQueryAliases,proto3" json:"database_query_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *UpdateRootOP) Reset()         { *m = UpdateRootOP{} }
func (m *UpdateRootOP) String() string { return proto.CompactTextString(m) }
func (*UpdateRootOP) ProtoMessage()    {}
func (*UpdateRootOP) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{1}
}
func (m *UpdateRootOP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateRootOP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateRootOP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateRootOP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateRootOP.Merge(m, src)
}
func (m *UpdateRootOP) XXX_Size() int {
	return m.Size()
}
func (m *UpdateRootOP) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateRootOP.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateRootOP proto.InternalMessageInfo

func (m *UpdateRootOP) GetDatabaseIngestionAliases() map[string]string {
	if m != nil {
		return m.DatabaseIngestionAliases
	}
	return nil
}

func (m *UpdateRootOP) GetDatabaseQueryAliases() map[string]string {
	if m != nil {
		return m.DatabaseQueryAliases
	}
	return nil
}

type CreateDabaseOP struct {
	Name                      string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	NumOfPartitions           int32             `protobuf:"varint,2,opt,name=num_of_partitions,json=numOfPartitions,proto3" json:"num_of_partitions,omitempty"`
	PartitionAllocMap         []*NodeIdList     `protobuf:"bytes,3,rep,name=partition_alloc_map,json=partitionAllocMap,proto3" json:"partition_alloc_map,omitempty"`
	TableIngestionAliases     map[string]string `protobuf:"bytes,4,rep,name=table_ingestion_aliases,json=tableIngestionAliases,proto3" json:"table_ingestion_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TableQueryAliases         map[string]string `protobuf:"bytes,5,rep,name=table_query_aliases,json=tableQueryAliases,proto3" json:"table_query_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	AllowDynamicTableCreation bool              `protobuf:"varint,6,opt,name=allow_dynamic_table_creation,json=allowDynamicTableCreation,proto3" json:"allow_dynamic_table_creation,omitempty"`
}

func (m *CreateDabaseOP) Reset()         { *m = CreateDabaseOP{} }
func (m *CreateDabaseOP) String() string { return proto.CompactTextString(m) }
func (*CreateDabaseOP) ProtoMessage()    {}
func (*CreateDabaseOP) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{2}
}
func (m *CreateDabaseOP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDabaseOP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDabaseOP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDabaseOP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDabaseOP.Merge(m, src)
}
func (m *CreateDabaseOP) XXX_Size() int {
	return m.Size()
}
func (m *CreateDabaseOP) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDabaseOP.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDabaseOP proto.InternalMessageInfo

func (m *CreateDabaseOP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateDabaseOP) GetNumOfPartitions() int32 {
	if m != nil {
		return m.NumOfPartitions
	}
	return 0
}

func (m *CreateDabaseOP) GetPartitionAllocMap() []*NodeIdList {
	if m != nil {
		return m.PartitionAllocMap
	}
	return nil
}

func (m *CreateDabaseOP) GetTableIngestionAliases() map[string]string {
	if m != nil {
		return m.TableIngestionAliases
	}
	return nil
}

func (m *CreateDabaseOP) GetTableQueryAliases() map[string]string {
	if m != nil {
		return m.TableQueryAliases
	}
	return nil
}

func (m *CreateDabaseOP) GetAllowDynamicTableCreation() bool {
	if m != nil {
		return m.AllowDynamicTableCreation
	}
	return false
}

type UpdateDabaseOP struct {
	Name                      string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	NumOfPartitions           int32             `protobuf:"varint,2,opt,name=num_of_partitions,json=numOfPartitions,proto3" json:"num_of_partitions,omitempty"`
	PartitionAllocMap         []*NodeIdList     `protobuf:"bytes,3,rep,name=partition_alloc_map,json=partitionAllocMap,proto3" json:"partition_alloc_map,omitempty"`
	TableIngestionAliases     map[string]string `protobuf:"bytes,4,rep,name=table_ingestion_aliases,json=tableIngestionAliases,proto3" json:"table_ingestion_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TableQueryAliases         map[string]string `protobuf:"bytes,5,rep,name=table_query_aliases,json=tableQueryAliases,proto3" json:"table_query_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	AllowDynamicTableCreation bool              `protobuf:"varint,6,opt,name=allow_dynamic_table_creation,json=allowDynamicTableCreation,proto3" json:"allow_dynamic_table_creation,omitempty"`
}

func (m *UpdateDabaseOP) Reset()         { *m = UpdateDabaseOP{} }
func (m *UpdateDabaseOP) String() string { return proto.CompactTextString(m) }
func (*UpdateDabaseOP) ProtoMessage()    {}
func (*UpdateDabaseOP) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{3}
}
func (m *UpdateDabaseOP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDabaseOP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDabaseOP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDabaseOP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDabaseOP.Merge(m, src)
}
func (m *UpdateDabaseOP) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDabaseOP) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDabaseOP.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDabaseOP proto.InternalMessageInfo

func (m *UpdateDabaseOP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateDabaseOP) GetNumOfPartitions() int32 {
	if m != nil {
		return m.NumOfPartitions
	}
	return 0
}

func (m *UpdateDabaseOP) GetPartitionAllocMap() []*NodeIdList {
	if m != nil {
		return m.PartitionAllocMap
	}
	return nil
}

func (m *UpdateDabaseOP) GetTableIngestionAliases() map[string]string {
	if m != nil {
		return m.TableIngestionAliases
	}
	return nil
}

func (m *UpdateDabaseOP) GetTableQueryAliases() map[string]string {
	if m != nil {
		return m.TableQueryAliases
	}
	return nil
}

func (m *UpdateDabaseOP) GetAllowDynamicTableCreation() bool {
	if m != nil {
		return m.AllowDynamicTableCreation
	}
	return false
}

type DeleteDabaseOP struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *DeleteDabaseOP) Reset()         { *m = DeleteDabaseOP{} }
func (m *DeleteDabaseOP) String() string { return proto.CompactTextString(m) }
func (*DeleteDabaseOP) ProtoMessage()    {}
func (*DeleteDabaseOP) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{4}
}
func (m *DeleteDabaseOP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteDabaseOP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteDabaseOP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteDabaseOP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteDabaseOP.Merge(m, src)
}
func (m *DeleteDabaseOP) XXX_Size() int {
	return m.Size()
}
func (m *DeleteDabaseOP) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteDabaseOP.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteDabaseOP proto.InternalMessageInfo

func (m *DeleteDabaseOP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ColumnMapping struct {
	Type     storage.ColumnType `protobuf:"varint,1,opt,name=type,proto3,enum=meerkat.storage.ColumnType" json:"type,omitempty"`
	Nullable bool               `protobuf:"varint,2,opt,name=nullable,proto3" json:"nullable,omitempty"`
	Indexed  bool               `protobuf:"varint,3,opt,name=indexed,proto3" json:"indexed,omitempty"`
}

func (m *ColumnMapping) Reset()         { *m = ColumnMapping{} }
func (m *ColumnMapping) String() string { return proto.CompactTextString(m) }
func (*ColumnMapping) ProtoMessage()    {}
func (*ColumnMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{5}
}
func (m *ColumnMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnMapping.Merge(m, src)
}
func (m *ColumnMapping) XXX_Size() int {
	return m.Size()
}
func (m *ColumnMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnMapping.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnMapping proto.InternalMessageInfo

func (m *ColumnMapping) GetType() storage.ColumnType {
	if m != nil {
		return m.Type
	}
	return storage.ColumnType_TIMESTAMP
}

func (m *ColumnMapping) GetNullable() bool {
	if m != nil {
		return m.Nullable
	}
	return false
}

func (m *ColumnMapping) GetIndexed() bool {
	if m != nil {
		return m.Indexed
	}
	return false
}

type CreateTableOP struct {
	Name                       string                    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Database                   string                    `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	NumOfPartitions            int32                     `protobuf:"varint,3,opt,name=num_of_partitions,json=numOfPartitions,proto3" json:"num_of_partitions,omitempty"`
	PartitionAllocMap          []*NodeIdList             `protobuf:"bytes,4,rep,name=partition_alloc_map,json=partitionAllocMap,proto3" json:"partition_alloc_map,omitempty"`
	AllowDynamicColumnCreation bool                      `protobuf:"varint,5,opt,name=allow_dynamic_column_creation,json=allowDynamicColumnCreation,proto3" json:"allow_dynamic_column_creation,omitempty"`
	ColumnMappings             map[string]*ColumnMapping `protobuf:"bytes,6,rep,name=column_mappings,json=columnMappings,proto3" json:"column_mappings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ColumnQueryAliases         map[string]string         `protobuf:"bytes,7,rep,name=column_query_aliases,json=columnQueryAliases,proto3" json:"column_query_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ColumnIngestionAliases     map[string]string         `protobuf:"bytes,8,rep,name=column_ingestion_aliases,json=columnIngestionAliases,proto3" json:"column_ingestion_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CreateTableOP) Reset()         { *m = CreateTableOP{} }
func (m *CreateTableOP) String() string { return proto.CompactTextString(m) }
func (*CreateTableOP) ProtoMessage()    {}
func (*CreateTableOP) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{6}
}
func (m *CreateTableOP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTableOP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTableOP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTableOP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTableOP.Merge(m, src)
}
func (m *CreateTableOP) XXX_Size() int {
	return m.Size()
}
func (m *CreateTableOP) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTableOP.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTableOP proto.InternalMessageInfo

func (m *CreateTableOP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateTableOP) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateTableOP) GetNumOfPartitions() int32 {
	if m != nil {
		return m.NumOfPartitions
	}
	return 0
}

func (m *CreateTableOP) GetPartitionAllocMap() []*NodeIdList {
	if m != nil {
		return m.PartitionAllocMap
	}
	return nil
}

func (m *CreateTableOP) GetAllowDynamicColumnCreation() bool {
	if m != nil {
		return m.AllowDynamicColumnCreation
	}
	return false
}

func (m *CreateTableOP) GetColumnMappings() map[string]*ColumnMapping {
	if m != nil {
		return m.ColumnMappings
	}
	return nil
}

func (m *CreateTableOP) GetColumnQueryAliases() map[string]string {
	if m != nil {
		return m.ColumnQueryAliases
	}
	return nil
}

func (m *CreateTableOP) GetColumnIngestionAliases() map[string]string {
	if m != nil {
		return m.ColumnIngestionAliases
	}
	return nil
}

type UpdateTableOP struct {
	Name                       string                    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Database                   string                    `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	PartitionAllocMap          []*NodeIdList             `protobuf:"bytes,4,rep,name=partition_alloc_map,json=partitionAllocMap,proto3" json:"partition_alloc_map,omitempty"`
	AllowDynamicColumnCreation bool                      `protobuf:"varint,5,opt,name=allow_dynamic_column_creation,json=allowDynamicColumnCreation,proto3" json:"allow_dynamic_column_creation,omitempty"`
	ColumnMappings             map[string]*ColumnMapping `protobuf:"bytes,6,rep,name=column_mappings,json=columnMappings,proto3" json:"column_mappings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ColumnQueryAliases         map[string]string         `protobuf:"bytes,7,rep,name=column_query_aliases,json=columnQueryAliases,proto3" json:"column_query_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ColumnIngestionAliases     map[string]string         `protobuf:"bytes,8,rep,name=column_ingestion_aliases,json=columnIngestionAliases,proto3" json:"column_ingestion_aliases,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *UpdateTableOP) Reset()         { *m = UpdateTableOP{} }
func (m *UpdateTableOP) String() string { return proto.CompactTextString(m) }
func (*UpdateTableOP) ProtoMessage()    {}
func (*UpdateTableOP) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{7}
}
func (m *UpdateTableOP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTableOP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTableOP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTableOP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTableOP.Merge(m, src)
}
func (m *UpdateTableOP) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTableOP) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTableOP.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTableOP proto.InternalMessageInfo

func (m *UpdateTableOP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateTableOP) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *UpdateTableOP) GetPartitionAllocMap() []*NodeIdList {
	if m != nil {
		return m.PartitionAllocMap
	}
	return nil
}

func (m *UpdateTableOP) GetAllowDynamicColumnCreation() bool {
	if m != nil {
		return m.AllowDynamicColumnCreation
	}
	return false
}

func (m *UpdateTableOP) GetColumnMappings() map[string]*ColumnMapping {
	if m != nil {
		return m.ColumnMappings
	}
	return nil
}

func (m *UpdateTableOP) GetColumnQueryAliases() map[string]string {
	if m != nil {
		return m.ColumnQueryAliases
	}
	return nil
}

func (m *UpdateTableOP) GetColumnIngestionAliases() map[string]string {
	if m != nil {
		return m.ColumnIngestionAliases
	}
	return nil
}

type DeleteTableOP struct {
	Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Database string `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
}

func (m *DeleteTableOP) Reset()         { *m = DeleteTableOP{} }
func (m *DeleteTableOP) String() string { return proto.CompactTextString(m) }
func (*DeleteTableOP) ProtoMessage()    {}
func (*DeleteTableOP) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{8}
}
func (m *DeleteTableOP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteTableOP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteTableOP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteTableOP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteTableOP.Merge(m, src)
}
func (m *DeleteTableOP) XXX_Size() int {
	return m.Size()
}
func (m *DeleteTableOP) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteTableOP.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteTableOP proto.InternalMessageInfo

func (m *DeleteTableOP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeleteTableOP) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type LogEntry struct {
	Id   []byte    `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Time time.Time `protobuf:"bytes,2,opt,name=time,proto3,stdtime" json:"time"`
	Src  string    `protobuf:"bytes,3,opt,name=src,proto3" json:"src,omitempty"`
	// Types that are valid to be assigned to Op:
	//	*LogEntry_UpdateRootOp
	//	*LogEntry_CreateDatabaseOp
	//	*LogEntry_UpdateDatabaseOp
	//	*LogEntry_DeletaDatabseOp
	//	*LogEntry_CreateTableOp
	//	*LogEntry_UpdateTableOp
	//	*LogEntry_DeleteTableOp
	Op isLogEntry_Op `protobuf_oneof:"op"`
}

func (m *LogEntry) Reset()         { *m = LogEntry{} }
func (m *LogEntry) String() string { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()    {}
func (*LogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{9}
}
func (m *LogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogEntry.Merge(m, src)
}
func (m *LogEntry) XXX_Size() int {
	return m.Size()
}
func (m *LogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LogEntry proto.InternalMessageInfo

type isLogEntry_Op interface {
	isLogEntry_Op()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LogEntry_UpdateRootOp struct {
	UpdateRootOp *UpdateRootOP `protobuf:"bytes,4,opt,name=update_root_op,json=updateRootOp,proto3,oneof" json:"update_root_op,omitempty"`
}
type LogEntry_CreateDatabaseOp struct {
	CreateDatabaseOp *CreateDabaseOP `protobuf:"bytes,5,opt,name=create_database_op,json=createDatabaseOp,proto3,oneof" json:"create_database_op,omitempty"`
}
type LogEntry_UpdateDatabaseOp struct {
	UpdateDatabaseOp *UpdateDabaseOP `protobuf:"bytes,6,opt,name=update_database_op,json=updateDatabaseOp,proto3,oneof" json:"update_database_op,omitempty"`
}
type LogEntry_DeletaDatabseOp struct {
	DeletaDatabseOp *DeleteDabaseOP `protobuf:"bytes,7,opt,name=deleta_databse_op,json=deletaDatabseOp,proto3,oneof" json:"deleta_databse_op,omitempty"`
}
type LogEntry_CreateTableOp struct {
	CreateTableOp *CreateTableOP `protobuf:"bytes,8,opt,name=create_table_op,json=createTableOp,proto3,oneof" json:"create_table_op,omitempty"`
}
type LogEntry_UpdateTableOp struct {
	UpdateTableOp *UpdateTableOP `protobuf:"bytes,9,opt,name=update_table_op,json=updateTableOp,proto3,oneof" json:"update_table_op,omitempty"`
}
type LogEntry_DeleteTableOp struct {
	DeleteTableOp *DeleteTableOP `protobuf:"bytes,10,opt,name=delete_table_op,json=deleteTableOp,proto3,oneof" json:"delete_table_op,omitempty"`
}

func (*LogEntry_UpdateRootOp) isLogEntry_Op()     {}
func (*LogEntry_CreateDatabaseOp) isLogEntry_Op() {}
func (*LogEntry_UpdateDatabaseOp) isLogEntry_Op() {}
func (*LogEntry_DeletaDatabseOp) isLogEntry_Op()  {}
func (*LogEntry_CreateTableOp) isLogEntry_Op()    {}
func (*LogEntry_UpdateTableOp) isLogEntry_Op()    {}
func (*LogEntry_DeleteTableOp) isLogEntry_Op()    {}

func (m *LogEntry) GetOp() isLogEntry_Op {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *LogEntry) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *LogEntry) GetTime() time.Time {
	if m != nil {
		return m.Time
	}
	return time.Time{}
}

func (m *LogEntry) GetSrc() string {
	if m != nil {
		return m.Src
	}
	return ""
}

func (m *LogEntry) GetUpdateRootOp() *UpdateRootOP {
	if x, ok := m.GetOp().(*LogEntry_UpdateRootOp); ok {
		return x.UpdateRootOp
	}
	return nil
}

func (m *LogEntry) GetCreateDatabaseOp() *CreateDabaseOP {
	if x, ok := m.GetOp().(*LogEntry_CreateDatabaseOp); ok {
		return x.CreateDatabaseOp
	}
	return nil
}

func (m *LogEntry) GetUpdateDatabaseOp() *UpdateDabaseOP {
	if x, ok := m.GetOp().(*LogEntry_UpdateDatabaseOp); ok {
		return x.UpdateDatabaseOp
	}
	return nil
}

func (m *LogEntry) GetDeletaDatabseOp() *DeleteDabaseOP {
	if x, ok := m.GetOp().(*LogEntry_DeletaDatabseOp); ok {
		return x.DeletaDatabseOp
	}
	return nil
}

func (m *LogEntry) GetCreateTableOp() *CreateTableOP {
	if x, ok := m.GetOp().(*LogEntry_CreateTableOp); ok {
		return x.CreateTableOp
	}
	return nil
}

func (m *LogEntry) GetUpdateTableOp() *UpdateTableOP {
	if x, ok := m.GetOp().(*LogEntry_UpdateTableOp); ok {
		return x.UpdateTableOp
	}
	return nil
}

func (m *LogEntry) GetDeleteTableOp() *DeleteTableOP {
	if x, ok := m.GetOp().(*LogEntry_DeleteTableOp); ok {
		return x.DeleteTableOp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LogEntry) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LogEntry_UpdateRootOp)(nil),
		(*LogEntry_CreateDatabaseOp)(nil),
		(*LogEntry_UpdateDatabaseOp)(nil),
		(*LogEntry_DeletaDatabseOp)(nil),
		(*LogEntry_CreateTableOp)(nil),
		(*LogEntry_UpdateTableOp)(nil),
		(*LogEntry_DeleteTableOp)(nil),
	}
}

type AddLogEntryRequest struct {
	Entries []LogEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries"`
}

func (m *AddLogEntryRequest) Reset()         { *m = AddLogEntryRequest{} }
func (m *AddLogEntryRequest) String() string { return proto.CompactTextString(m) }
func (*AddLogEntryRequest) ProtoMessage()    {}
func (*AddLogEntryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{10}
}
func (m *AddLogEntryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddLogEntryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddLogEntryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddLogEntryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddLogEntryRequest.Merge(m, src)
}
func (m *AddLogEntryRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddLogEntryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddLogEntryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddLogEntryRequest proto.InternalMessageInfo

func (m *AddLogEntryRequest) GetEntries() []LogEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type AddLogEntryResponse struct {
}

func (m *AddLogEntryResponse) Reset()         { *m = AddLogEntryResponse{} }
func (m *AddLogEntryResponse) String() string { return proto.CompactTextString(m) }
func (*AddLogEntryResponse) ProtoMessage()    {}
func (*AddLogEntryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{11}
}
func (m *AddLogEntryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddLogEntryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddLogEntryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddLogEntryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddLogEntryResponse.Merge(m, src)
}
func (m *AddLogEntryResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddLogEntryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddLogEntryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddLogEntryResponse proto.InternalMessageInfo

type SnapshotRequest struct {
}

func (m *SnapshotRequest) Reset()         { *m = SnapshotRequest{} }
func (m *SnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*SnapshotRequest) ProtoMessage()    {}
func (*SnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{12}
}
func (m *SnapshotRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotRequest.Merge(m, src)
}
func (m *SnapshotRequest) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotRequest proto.InternalMessageInfo

type SnapshotResponse struct {
	Entries []LogEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries"`
}

func (m *SnapshotResponse) Reset()         { *m = SnapshotResponse{} }
func (m *SnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*SnapshotResponse) ProtoMessage()    {}
func (*SnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{13}
}
func (m *SnapshotResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotResponse.Merge(m, src)
}
func (m *SnapshotResponse) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotResponse proto.InternalMessageInfo

func (m *SnapshotResponse) GetEntries() []LogEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterType((*NodeIdList)(nil), "meerkat.cluster.NodeIdList")
	proto.RegisterType((*UpdateRootOP)(nil), "meerkat.cluster.UpdateRootOP")
	proto.RegisterMapType((map[string]string)(nil), "meerkat.cluster.UpdateRootOP.DatabaseIngestionAliasesEntry")
	proto.RegisterMapType((map[string]string)(nil), "meerkat.cluster.UpdateRootOP.DatabaseQueryAliasesEntry")
	proto.RegisterType((*CreateDabaseOP)(nil), "meerkat.cluster.CreateDabaseOP")
	proto.RegisterMapType((map[string]string)(nil), "meerkat.cluster.CreateDabaseOP.TableIngestionAliasesEntry")
	proto.RegisterMapType((map[string]string)(nil), "meerkat.cluster.CreateDabaseOP.TableQueryAliasesEntry")
	proto.RegisterType((*UpdateDabaseOP)(nil), "meerkat.cluster.UpdateDabaseOP")
	proto.RegisterMapType((map[string]string)(nil), "meerkat.cluster.UpdateDabaseOP.TableIngestionAliasesEntry")
	proto.RegisterMapType((map[string]string)(nil), "meerkat.cluster.UpdateDabaseOP.TableQueryAliasesEntry")
	proto.RegisterType((*DeleteDabaseOP)(nil), "meerkat.cluster.DeleteDabaseOP")
	proto.RegisterType((*ColumnMapping)(nil), "meerkat.cluster.ColumnMapping")
	proto.RegisterType((*CreateTableOP)(nil), "meerkat.cluster.CreateTableOP")
	proto.RegisterMapType((map[string]string)(nil), "meerkat.cluster.CreateTableOP.ColumnIngestionAliasesEntry")
	proto.RegisterMapType((map[string]*ColumnMapping)(nil), "meerkat.cluster.CreateTableOP.ColumnMappingsEntry")
	proto.RegisterMapType((map[string]string)(nil), "meerkat.cluster.CreateTableOP.ColumnQueryAliasesEntry")
	proto.RegisterType((*UpdateTableOP)(nil), "meerkat.cluster.UpdateTableOP")
	proto.RegisterMapType((map[string]string)(nil), "meerkat.cluster.UpdateTableOP.ColumnIngestionAliasesEntry")
	proto.RegisterMapType((map[string]*ColumnMapping)(nil), "meerkat.cluster.UpdateTableOP.ColumnMappingsEntry")
	proto.RegisterMapType((map[string]string)(nil), "meerkat.cluster.UpdateTableOP.ColumnQueryAliasesEntry")
	proto.RegisterType((*DeleteTableOP)(nil), "meerkat.cluster.DeleteTableOP")
	proto.RegisterType((*LogEntry)(nil), "meerkat.cluster.LogEntry")
	proto.RegisterType((*AddLogEntryRequest)(nil), "meerkat.cluster.AddLogEntryRequest")
	proto.RegisterType((*AddLogEntryResponse)(nil), "meerkat.cluster.AddLogEntryResponse")
	proto.RegisterType((*SnapshotRequest)(nil), "meerkat.cluster.SnapshotRequest")
	proto.RegisterType((*SnapshotResponse)(nil), "meerkat.cluster.SnapshotResponse")
}

func init() { proto.RegisterFile("metadata.proto", fileDescriptor_56d9f74966f40d04) }

var fileDescriptor_56d9f74966f40d04 = []byte{
	// 1139 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x4d, 0x53, 0xdb, 0xc6,
	0x1b, 0xf7, 0x1b, 0xc6, 0x79, 0xc0, 0x36, 0x2c, 0x04, 0x8c, 0xf2, 0xc7, 0xf0, 0x57, 0xd3, 0x19,
	0xa6, 0x07, 0x33, 0x43, 0x3b, 0x6d, 0x9a, 0x1e, 0x32, 0x80, 0x99, 0x9a, 0x49, 0xa8, 0x89, 0x42,
	0x2f, 0xe9, 0x41, 0xb3, 0x48, 0x8b, 0xd1, 0x44, 0xd2, 0x2a, 0xd2, 0x2a, 0xad, 0x8f, 0xed, 0x07,
	0xe8, 0xe4, 0x8b, 0xf4, 0x03, 0xf4, 0x1b, 0x64, 0x7a, 0xca, 0xb1, 0xa7, 0xb6, 0x03, 0x5f, 0xa4,
	0xa3, 0x5d, 0x49, 0x48, 0x48, 0x72, 0x62, 0x3a, 0x1c, 0xfa, 0x72, 0xd3, 0x3e, 0xfb, 0x3c, 0xbf,
	0xe7, 0xc5, 0xbf, 0x9f, 0x56, 0x6b, 0x68, 0x59, 0x84, 0x61, 0x1d, 0x33, 0xdc, 0x73, 0x5c, 0xca,
	0x28, 0x6a, 0x5b, 0x84, 0xb8, 0x2f, 0x30, 0xeb, 0x69, 0xa6, 0xef, 0x31, 0xe2, 0x4a, 0xcb, 0x23,
	0x3a, 0xa2, 0x7c, 0x6f, 0x3b, 0x78, 0x12, 0x6e, 0xd2, 0xc6, 0x88, 0xd2, 0x91, 0x49, 0xb6, 0xf9,
	0xea, 0xd4, 0x3f, 0xdb, 0x66, 0x86, 0x45, 0x3c, 0x86, 0x2d, 0x27, 0x74, 0x68, 0x7a, 0x8c, 0xba,
	0x78, 0x44, 0xc4, 0x52, 0xfe, 0x10, 0xe0, 0x2b, 0xaa, 0x93, 0x43, 0xfd, 0x89, 0xe1, 0x31, 0xb4,
	0x0a, 0xb3, 0x36, 0xd5, 0x89, 0x6a, 0xe8, 0x9d, 0xf2, 0x66, 0x75, 0x6b, 0x5e, 0xa9, 0xdb, 0x7c,
	0x53, 0xfe, 0xb1, 0x0a, 0xf3, 0x5f, 0x3b, 0x3a, 0x66, 0x44, 0xa1, 0x94, 0x0d, 0x8f, 0xd1, 0x18,
	0xa4, 0xa0, 0xb8, 0x53, 0xec, 0x11, 0xd5, 0xb0, 0x47, 0xc4, 0x63, 0x06, 0xb5, 0x55, 0x6c, 0x1a,
	0xd8, 0x23, 0x1e, 0x0f, 0x9e, 0xdb, 0xf9, 0xa2, 0x77, 0xad, 0xe6, 0x5e, 0x12, 0xa2, 0xd7, 0x0f,
	0xe3, 0x0f, 0xa3, 0xf0, 0x5d, 0x11, 0x7d, 0x60, 0x33, 0x77, 0xac, 0x74, 0xf4, 0x82, 0x6d, 0x64,
	0xc1, 0x4a, 0x9c, 0xfa, 0xa5, 0x4f, 0xdc, 0x71, 0x9c, 0xb6, 0xc2, 0xd3, 0x7e, 0xf6, 0x7e, 0x69,
	0x9f, 0x06, 0xa1, 0xa9, 0x94, 0xcb, 0x7a, 0xce, 0x96, 0xf4, 0x18, 0xd6, 0x27, 0x56, 0x8a, 0x16,
	0xa0, 0xfa, 0x82, 0x8c, 0x3b, 0xe5, 0xcd, 0xf2, 0xd6, 0x1d, 0x25, 0x78, 0x44, 0xcb, 0x30, 0xf3,
	0x0a, 0x9b, 0x3e, 0xe9, 0x54, 0xb8, 0x4d, 0x2c, 0x1e, 0x56, 0x1e, 0x94, 0xa5, 0x2f, 0x61, 0xad,
	0x30, 0xff, 0x34, 0x40, 0xf2, 0x2f, 0x35, 0x68, 0xed, 0xbb, 0x04, 0x33, 0xd2, 0xe7, 0x68, 0xc3,
	0x63, 0x84, 0xa0, 0x66, 0x63, 0x8b, 0x84, 0xf1, 0xfc, 0x19, 0x7d, 0x04, 0x8b, 0xb6, 0x6f, 0xa9,
	0xf4, 0x4c, 0x75, 0xb0, 0xcb, 0x8c, 0xa0, 0x76, 0x8f, 0x83, 0xcd, 0x28, 0x6d, 0xdb, 0xb7, 0x86,
	0x67, 0xc7, 0xb1, 0x19, 0x3d, 0x86, 0xa5, 0xd8, 0x49, 0xc5, 0xa6, 0x49, 0x35, 0xd5, 0xc2, 0x4e,
	0xa7, 0xca, 0x87, 0x7a, 0x2f, 0x33, 0xd4, 0x2b, 0xda, 0x28, 0x8b, 0x71, 0xdc, 0x6e, 0x10, 0x76,
	0x84, 0x1d, 0xe4, 0xc2, 0x2a, 0xc3, 0xa7, 0x66, 0x1e, 0x39, 0x6a, 0x1c, 0xf0, 0x61, 0x06, 0x30,
	0xdd, 0x4e, 0xef, 0x24, 0x08, 0xcf, 0xe7, 0xc6, 0x5d, 0x96, 0xb7, 0x87, 0xce, 0x60, 0x49, 0xe4,
	0x4c, 0xb3, 0x62, 0x86, 0xe7, 0xfb, 0xf4, 0xbd, 0xf2, 0x65, 0x49, 0xb1, 0xc8, 0xae, 0xdb, 0xd1,
	0x23, 0xf8, 0x5f, 0x30, 0x9e, 0x6f, 0x55, 0x7d, 0x6c, 0x63, 0xcb, 0xd0, 0x54, 0x91, 0x55, 0x0b,
	0xf0, 0x0c, 0x6a, 0x77, 0xea, 0x9b, 0xe5, 0xad, 0x86, 0xb2, 0xc6, 0x7d, 0xfa, 0xc2, 0x85, 0x83,
	0xef, 0x87, 0x0e, 0xd2, 0x00, 0xa4, 0xe2, 0xee, 0xa6, 0xe2, 0x53, 0x1f, 0x56, 0xf2, 0xeb, 0x9e,
	0x9a, 0x4c, 0x42, 0x23, 0xff, 0x18, 0x32, 0xa5, 0xdb, 0xb9, 0x7d, 0x32, 0xe5, 0xe5, 0xfb, 0x77,
	0x92, 0xe9, 0x3e, 0xb4, 0xfa, 0xc4, 0x24, 0x93, 0xb9, 0x24, 0xbf, 0x82, 0xe6, 0x3e, 0x35, 0x7d,
	0xcb, 0x3e, 0xc2, 0x8e, 0x63, 0xd8, 0x23, 0xb4, 0x0d, 0x35, 0x36, 0x76, 0x84, 0x53, 0x2b, 0xc1,
	0x90, 0xe8, 0xb8, 0x12, 0xde, 0x27, 0x63, 0x87, 0x28, 0xdc, 0x11, 0x49, 0xd0, 0xb0, 0x7d, 0xd3,
	0x0c, 0x0a, 0xe6, 0x45, 0x34, 0x94, 0x78, 0x8d, 0x3a, 0x30, 0x6b, 0xd8, 0x3a, 0xf9, 0x8e, 0xe8,
	0x9d, 0x2a, 0xdf, 0x8a, 0x96, 0xf2, 0x4f, 0x75, 0x68, 0x0a, 0xe1, 0xf3, 0x56, 0x0b, 0x98, 0x2e,
	0x41, 0x23, 0x3a, 0x0b, 0xc2, 0x06, 0xe3, 0x75, 0xbe, 0x0a, 0xaa, 0x53, 0xa9, 0xa0, 0x76, 0x23,
	0x15, 0xec, 0xc2, 0x7a, 0x9a, 0x29, 0x1a, 0x1f, 0xc9, 0x15, 0x55, 0x66, 0x78, 0xab, 0x52, 0x92,
	0x2a, 0x62, 0x6a, 0x11, 0x57, 0xd0, 0x37, 0xd0, 0x0e, 0x83, 0x2c, 0x31, 0x76, 0xaf, 0x53, 0xe7,
	0xb5, 0xec, 0x14, 0xbc, 0x1d, 0xc3, 0x21, 0xf5, 0x52, 0xbf, 0x55, 0x48, 0xe6, 0x96, 0x96, 0x32,
	0xa2, 0x73, 0x58, 0x0e, 0xc1, 0xd3, 0x92, 0x99, 0x9d, 0xf8, 0xfe, 0x4d, 0x67, 0xc8, 0x4a, 0x06,
	0x69, 0x99, 0x0d, 0xc4, 0xa0, 0x13, 0x66, 0xca, 0xbe, 0x10, 0x1a, 0x13, 0x4f, 0x97, 0x74, 0xb6,
	0xfc, 0x17, 0xc2, 0x8a, 0x96, 0xbb, 0x29, 0x61, 0x58, 0xca, 0x19, 0x43, 0x8e, 0x36, 0x3e, 0x49,
	0x6a, 0x63, 0x6e, 0xa7, 0x9b, 0xad, 0x25, 0x09, 0x93, 0x54, 0xe0, 0x01, 0xac, 0x16, 0xcc, 0x61,
	0x2a, 0x21, 0x1f, 0xc2, 0xbd, 0x09, 0x0d, 0x4e, 0xa5, 0xe6, 0xef, 0xeb, 0xd0, 0x14, 0xef, 0xb6,
	0x9b, 0xea, 0xe5, 0x6f, 0xac, 0x81, 0x54, 0xe3, 0xb7, 0xa2, 0x81, 0xbc, 0x0c, 0xb7, 0xa7, 0x81,
	0xbc, 0x6c, 0xff, 0x69, 0xe0, 0x9d, 0x1a, 0x78, 0x04, 0x4d, 0x71, 0xa2, 0xdd, 0x50, 0x02, 0xf2,
	0x0f, 0x33, 0xd0, 0x78, 0x42, 0x47, 0x22, 0x73, 0x0b, 0x2a, 0xfc, 0x7a, 0x55, 0xde, 0x9a, 0x57,
	0x2a, 0x86, 0x8e, 0x1e, 0x40, 0x2d, 0xb8, 0xa3, 0x85, 0x83, 0x92, 0x7a, 0xe2, 0x02, 0xd7, 0x8b,
	0x2e, 0x70, 0xbd, 0x93, 0xe8, 0x02, 0xb7, 0xd7, 0x78, 0xf3, 0xdb, 0x46, 0xe9, 0xf5, 0xef, 0x1b,
	0x65, 0x85, 0x47, 0x04, 0x3d, 0x78, 0xae, 0xc6, 0xcf, 0x9e, 0x3b, 0x4a, 0xf0, 0x88, 0x0e, 0xa0,
	0xe5, 0xf3, 0xdf, 0x58, 0x75, 0x29, 0x65, 0x2a, 0x0d, 0x64, 0x16, 0xa0, 0xae, 0x4f, 0xbc, 0x12,
	0x0d, 0x4a, 0xca, 0xbc, 0x7f, 0xb5, 0x76, 0xd0, 0x10, 0x10, 0x17, 0x14, 0x51, 0xe3, 0x8b, 0x16,
	0x75, 0xb8, 0xb4, 0xe6, 0x76, 0x36, 0xde, 0xf1, 0x1d, 0x3d, 0x28, 0x29, 0x0b, 0x5a, 0x68, 0x11,
	0xb1, 0x02, 0x30, 0xac, 0x2b, 0x09, 0x58, 0x2f, 0x00, 0x4c, 0x7f, 0x4b, 0x05, 0x80, 0x7e, 0x68,
	0x89, 0x01, 0x8f, 0x60, 0x51, 0x0f, 0x7e, 0x12, 0x2c, 0x00, 0x05, 0xde, 0x6c, 0x01, 0x5e, 0xfa,
	0x73, 0x64, 0x50, 0x52, 0xda, 0x22, 0xb6, 0x2f, 0x42, 0x87, 0x0e, 0x1a, 0x40, 0x3b, 0x6c, 0x58,
	0x7c, 0x7d, 0x51, 0xa7, 0xd3, 0x28, 0xe2, 0x6d, 0xf2, 0x1c, 0x19, 0x94, 0x94, 0xa6, 0x96, 0x30,
	0x70, 0xa4, 0xb0, 0xd3, 0x18, 0xe9, 0x4e, 0x01, 0x52, 0x4a, 0x8d, 0x01, 0x92, 0x9f, 0x30, 0x70,
	0x24, 0x5e, 0x66, 0x02, 0x09, 0x0a, 0x90, 0x52, 0xec, 0x0c, 0x90, 0xf4, 0x84, 0xc1, 0xd9, 0xab,
	0x41, 0x85, 0x3a, 0xf2, 0x10, 0xd0, 0xae, 0xae, 0x47, 0x34, 0x54, 0xc8, 0x4b, 0x9f, 0x78, 0x0c,
	0x7d, 0x0e, 0xb3, 0xc4, 0x66, 0xae, 0x11, 0x5f, 0xda, 0xd7, 0x32, 0xe8, 0x51, 0xc8, 0x5e, 0x2d,
	0xe0, 0x9f, 0x12, 0xf9, 0xcb, 0x77, 0x61, 0x29, 0x05, 0xe8, 0x39, 0xd4, 0xf6, 0x88, 0xbc, 0x08,
	0xed, 0x67, 0x36, 0x76, 0xbc, 0x73, 0xca, 0xc2, 0x24, 0xf2, 0x11, 0x2c, 0x5c, 0x99, 0x84, 0xdb,
	0x5f, 0x48, 0xbc, 0xf3, 0x73, 0x19, 0x1a, 0x47, 0xe1, 0xbf, 0x23, 0xe8, 0x39, 0xcc, 0x25, 0xaa,
	0x40, 0x1f, 0x64, 0x50, 0xb2, 0x4d, 0x4b, 0xf7, 0x27, 0x3b, 0x85, 0x8d, 0x94, 0xd0, 0x53, 0x68,
	0x04, 0x75, 0x3f, 0x3b, 0xa7, 0x0c, 0x6d, 0x66, 0x62, 0xae, 0x75, 0x29, 0xfd, 0x7f, 0x82, 0x47,
	0x04, 0xb9, 0x27, 0xbf, 0xb9, 0xe8, 0x96, 0xdf, 0x5e, 0x74, 0xcb, 0x7f, 0x5c, 0x74, 0xcb, 0xaf,
	0x2f, 0xbb, 0xa5, 0xb7, 0x97, 0xdd, 0xd2, 0xaf, 0x97, 0xdd, 0xd2, 0xf3, 0x46, 0xf4, 0x87, 0xcf,
	0x69, 0x9d, 0x6b, 0xff, 0xe3, 0x3f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xa1, 0x73, 0xb5, 0x6d, 0x03,
	0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MetadataClient is the client API for Metadata service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetadataClient interface {
	AddLogEntry(ctx context.Context, in *AddLogEntryRequest, opts ...grpc.CallOption) (*AddLogEntryResponse, error)
	SnapShot(ctx context.Context, in *SnapshotRequest, opts ...grpc.CallOption) (*SnapshotResponse, error)
}

type metadataClient struct {
	cc *grpc.ClientConn
}

func NewMetadataClient(cc *grpc.ClientConn) MetadataClient {
	return &metadataClient{cc}
}

func (c *metadataClient) AddLogEntry(ctx context.Context, in *AddLogEntryRequest, opts ...grpc.CallOption) (*AddLogEntryResponse, error) {
	out := new(AddLogEntryResponse)
	err := c.cc.Invoke(ctx, "/meerkat.cluster.Metadata/AddLogEntry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataClient) SnapShot(ctx context.Context, in *SnapshotRequest, opts ...grpc.CallOption) (*SnapshotResponse, error) {
	out := new(SnapshotResponse)
	err := c.cc.Invoke(ctx, "/meerkat.cluster.Metadata/SnapShot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetadataServer is the server API for Metadata service.
type MetadataServer interface {
	AddLogEntry(context.Context, *AddLogEntryRequest) (*AddLogEntryResponse, error)
	SnapShot(context.Context, *SnapshotRequest) (*SnapshotResponse, error)
}

// UnimplementedMetadataServer can be embedded to have forward compatible implementations.
type UnimplementedMetadataServer struct {
}

func (*UnimplementedMetadataServer) AddLogEntry(ctx context.Context, req *AddLogEntryRequest) (*AddLogEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLogEntry not implemented")
}
func (*UnimplementedMetadataServer) SnapShot(ctx context.Context, req *SnapshotRequest) (*SnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SnapShot not implemented")
}

func RegisterMetadataServer(s *grpc.Server, srv MetadataServer) {
	s.RegisterService(&_Metadata_serviceDesc, srv)
}

func _Metadata_AddLogEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddLogEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServer).AddLogEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/meerkat.cluster.Metadata/AddLogEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServer).AddLogEntry(ctx, req.(*AddLogEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Metadata_SnapShot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServer).SnapShot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/meerkat.cluster.Metadata/SnapShot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServer).SnapShot(ctx, req.(*SnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Metadata_serviceDesc = grpc.ServiceDesc{
	ServiceName: "meerkat.cluster.Metadata",
	HandlerType: (*MetadataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddLogEntry",
			Handler:    _Metadata_AddLogEntry_Handler,
		},
		{
			MethodName: "SnapShot",
			Handler:    _Metadata_SnapShot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "metadata.proto",
}

func (m *NodeIdList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeIdList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeIdList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		for iNdEx := len(m.NodeId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NodeId[iNdEx])
			copy(dAtA[i:], m.NodeId[iNdEx])
			i = encodeVarintMetadata(dAtA, i, uint64(len(m.NodeId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateRootOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateRootOP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateRootOP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DatabaseQueryAliases) > 0 {
		for k := range m.DatabaseQueryAliases {
			v := m.DatabaseQueryAliases[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetadata(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DatabaseIngestionAliases) > 0 {
		for k := range m.DatabaseIngestionAliases {
			v := m.DatabaseIngestionAliases[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetadata(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateDabaseOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDabaseOP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDabaseOP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowDynamicTableCreation {
		i--
		if m.AllowDynamicTableCreation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.TableQueryAliases) > 0 {
		for k := range m.TableQueryAliases {
			v := m.TableQueryAliases[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetadata(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TableIngestionAliases) > 0 {
		for k := range m.TableIngestionAliases {
			v := m.TableIngestionAliases[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetadata(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PartitionAllocMap) > 0 {
		for iNdEx := len(m.PartitionAllocMap) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionAllocMap[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.NumOfPartitions != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.NumOfPartitions))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDabaseOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDabaseOP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDabaseOP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowDynamicTableCreation {
		i--
		if m.AllowDynamicTableCreation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.TableQueryAliases) > 0 {
		for k := range m.TableQueryAliases {
			v := m.TableQueryAliases[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetadata(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TableIngestionAliases) > 0 {
		for k := range m.TableIngestionAliases {
			v := m.TableIngestionAliases[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetadata(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PartitionAllocMap) > 0 {
		for iNdEx := len(m.PartitionAllocMap) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionAllocMap[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.NumOfPartitions != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.NumOfPartitions))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteDabaseOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteDabaseOP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteDabaseOP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColumnMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Indexed {
		i--
		if m.Indexed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Nullable {
		i--
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateTableOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTableOP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTableOP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnIngestionAliases) > 0 {
		for k := range m.ColumnIngestionAliases {
			v := m.ColumnIngestionAliases[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetadata(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ColumnQueryAliases) > 0 {
		for k := range m.ColumnQueryAliases {
			v := m.ColumnQueryAliases[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetadata(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ColumnMappings) > 0 {
		for k := range m.ColumnMappings {
			v := m.ColumnMappings[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMetadata(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.AllowDynamicColumnCreation {
		i--
		if m.AllowDynamicColumnCreation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.PartitionAllocMap) > 0 {
		for iNdEx := len(m.PartitionAllocMap) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionAllocMap[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumOfPartitions != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.NumOfPartitions))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTableOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTableOP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTableOP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnIngestionAliases) > 0 {
		for k := range m.ColumnIngestionAliases {
			v := m.ColumnIngestionAliases[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetadata(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ColumnQueryAliases) > 0 {
		for k := range m.ColumnQueryAliases {
			v := m.ColumnQueryAliases[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMetadata(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ColumnMappings) > 0 {
		for k := range m.ColumnMappings {
			v := m.ColumnMappings[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintMetadata(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMetadata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMetadata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.AllowDynamicColumnCreation {
		i--
		if m.AllowDynamicColumnCreation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.PartitionAllocMap) > 0 {
		for iNdEx := len(m.PartitionAllocMap) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionAllocMap[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteTableOP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTableOP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteTableOP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Op != nil {
		{
			size := m.Op.Size()
			i -= size
			if _, err := m.Op.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Src) > 0 {
		i -= len(m.Src)
		copy(dAtA[i:], m.Src)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Src)))
		i--
		dAtA[i] = 0x1a
	}
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Time, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Time):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintMetadata(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x12
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogEntry_UpdateRootOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntry_UpdateRootOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateRootOp != nil {
		{
			size, err := m.UpdateRootOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *LogEntry_CreateDatabaseOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntry_CreateDatabaseOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateDatabaseOp != nil {
		{
			size, err := m.CreateDatabaseOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *LogEntry_UpdateDatabaseOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntry_UpdateDatabaseOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateDatabaseOp != nil {
		{
			size, err := m.UpdateDatabaseOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *LogEntry_DeletaDatabseOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntry_DeletaDatabseOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeletaDatabseOp != nil {
		{
			size, err := m.DeletaDatabseOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *LogEntry_CreateTableOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntry_CreateTableOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateTableOp != nil {
		{
			size, err := m.CreateTableOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *LogEntry_UpdateTableOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntry_UpdateTableOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateTableOp != nil {
		{
			size, err := m.UpdateTableOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *LogEntry_DeleteTableOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntry_DeleteTableOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteTableOp != nil {
		{
			size, err := m.DeleteTableOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *AddLogEntryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddLogEntryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddLogEntryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddLogEntryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddLogEntryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddLogEntryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SnapshotRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SnapshotResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetadata(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetadata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NodeIdList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		for _, b := range m.NodeId {
			l = len(b)
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	return n
}

func (m *UpdateRootOP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DatabaseIngestionAliases) > 0 {
		for k, v := range m.DatabaseIngestionAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + 1 + len(v) + sovMetadata(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	if len(m.DatabaseQueryAliases) > 0 {
		for k, v := range m.DatabaseQueryAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + 1 + len(v) + sovMetadata(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CreateDabaseOP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.NumOfPartitions != 0 {
		n += 1 + sovMetadata(uint64(m.NumOfPartitions))
	}
	if len(m.PartitionAllocMap) > 0 {
		for _, e := range m.PartitionAllocMap {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if len(m.TableIngestionAliases) > 0 {
		for k, v := range m.TableIngestionAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + 1 + len(v) + sovMetadata(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	if len(m.TableQueryAliases) > 0 {
		for k, v := range m.TableQueryAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + 1 + len(v) + sovMetadata(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	if m.AllowDynamicTableCreation {
		n += 2
	}
	return n
}

func (m *UpdateDabaseOP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.NumOfPartitions != 0 {
		n += 1 + sovMetadata(uint64(m.NumOfPartitions))
	}
	if len(m.PartitionAllocMap) > 0 {
		for _, e := range m.PartitionAllocMap {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if len(m.TableIngestionAliases) > 0 {
		for k, v := range m.TableIngestionAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + 1 + len(v) + sovMetadata(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	if len(m.TableQueryAliases) > 0 {
		for k, v := range m.TableQueryAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + 1 + len(v) + sovMetadata(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	if m.AllowDynamicTableCreation {
		n += 2
	}
	return n
}

func (m *DeleteDabaseOP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *ColumnMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMetadata(uint64(m.Type))
	}
	if m.Nullable {
		n += 2
	}
	if m.Indexed {
		n += 2
	}
	return n
}

func (m *CreateTableOP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.NumOfPartitions != 0 {
		n += 1 + sovMetadata(uint64(m.NumOfPartitions))
	}
	if len(m.PartitionAllocMap) > 0 {
		for _, e := range m.PartitionAllocMap {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if m.AllowDynamicColumnCreation {
		n += 2
	}
	if len(m.ColumnMappings) > 0 {
		for k, v := range m.ColumnMappings {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetadata(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	if len(m.ColumnQueryAliases) > 0 {
		for k, v := range m.ColumnQueryAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + 1 + len(v) + sovMetadata(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	if len(m.ColumnIngestionAliases) > 0 {
		for k, v := range m.ColumnIngestionAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + 1 + len(v) + sovMetadata(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *UpdateTableOP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if len(m.PartitionAllocMap) > 0 {
		for _, e := range m.PartitionAllocMap {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if m.AllowDynamicColumnCreation {
		n += 2
	}
	if len(m.ColumnMappings) > 0 {
		for k, v := range m.ColumnMappings {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetadata(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	if len(m.ColumnQueryAliases) > 0 {
		for k, v := range m.ColumnQueryAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + 1 + len(v) + sovMetadata(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	if len(m.ColumnIngestionAliases) > 0 {
		for k, v := range m.ColumnIngestionAliases {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetadata(uint64(len(k))) + 1 + len(v) + sovMetadata(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetadata(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DeleteTableOP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *LogEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)
	n += 1 + l + sovMetadata(uint64(l))
	l = len(m.Src)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.Op != nil {
		n += m.Op.Size()
	}
	return n
}

func (m *LogEntry_UpdateRootOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateRootOp != nil {
		l = m.UpdateRootOp.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}
func (m *LogEntry_CreateDatabaseOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateDatabaseOp != nil {
		l = m.CreateDatabaseOp.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}
func (m *LogEntry_UpdateDatabaseOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateDatabaseOp != nil {
		l = m.UpdateDatabaseOp.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}
func (m *LogEntry_DeletaDatabseOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeletaDatabseOp != nil {
		l = m.DeletaDatabseOp.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}
func (m *LogEntry_CreateTableOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateTableOp != nil {
		l = m.CreateTableOp.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}
func (m *LogEntry_UpdateTableOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateTableOp != nil {
		l = m.UpdateTableOp.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}
func (m *LogEntry_DeleteTableOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteTableOp != nil {
		l = m.DeleteTableOp.Size()
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}
func (m *AddLogEntryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	return n
}

func (m *AddLogEntryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SnapshotRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SnapshotResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	return n
}

func sovMetadata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetadata(x uint64) (n int) {
	return sovMetadata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodeIdList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeIdList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeIdList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = append(m.NodeId, make([]byte, postIndex-iNdEx))
			copy(m.NodeId[len(m.NodeId)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateRootOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateRootOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateRootOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseIngestionAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatabaseIngestionAliases == nil {
				m.DatabaseIngestionAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DatabaseIngestionAliases[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseQueryAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatabaseQueryAliases == nil {
				m.DatabaseQueryAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DatabaseQueryAliases[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDabaseOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDabaseOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDabaseOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPartitions", wireType)
			}
			m.NumOfPartitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPartitions |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionAllocMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionAllocMap = append(m.PartitionAllocMap, &NodeIdList{})
			if err := m.PartitionAllocMap[len(m.PartitionAllocMap)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableIngestionAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableIngestionAliases == nil {
				m.TableIngestionAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableIngestionAliases[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableQueryAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableQueryAliases == nil {
				m.TableQueryAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableQueryAliases[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDynamicTableCreation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowDynamicTableCreation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDabaseOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDabaseOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDabaseOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPartitions", wireType)
			}
			m.NumOfPartitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPartitions |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionAllocMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionAllocMap = append(m.PartitionAllocMap, &NodeIdList{})
			if err := m.PartitionAllocMap[len(m.PartitionAllocMap)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableIngestionAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableIngestionAliases == nil {
				m.TableIngestionAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableIngestionAliases[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableQueryAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableQueryAliases == nil {
				m.TableQueryAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableQueryAliases[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDynamicTableCreation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowDynamicTableCreation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteDabaseOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteDabaseOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteDabaseOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= storage.ColumnType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Indexed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTableOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTableOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTableOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPartitions", wireType)
			}
			m.NumOfPartitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPartitions |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionAllocMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionAllocMap = append(m.PartitionAllocMap, &NodeIdList{})
			if err := m.PartitionAllocMap[len(m.PartitionAllocMap)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDynamicColumnCreation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowDynamicColumnCreation = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnMappings == nil {
				m.ColumnMappings = make(map[string]*ColumnMapping)
			}
			var mapkey string
			var mapvalue *ColumnMapping
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetadata
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMetadata
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ColumnMapping{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ColumnMappings[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnQueryAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnQueryAliases == nil {
				m.ColumnQueryAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ColumnQueryAliases[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIngestionAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnIngestionAliases == nil {
				m.ColumnIngestionAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ColumnIngestionAliases[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTableOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTableOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTableOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionAllocMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionAllocMap = append(m.PartitionAllocMap, &NodeIdList{})
			if err := m.PartitionAllocMap[len(m.PartitionAllocMap)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDynamicColumnCreation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowDynamicColumnCreation = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnMappings == nil {
				m.ColumnMappings = make(map[string]*ColumnMapping)
			}
			var mapkey string
			var mapvalue *ColumnMapping
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetadata
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMetadata
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ColumnMapping{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ColumnMappings[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnQueryAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnQueryAliases == nil {
				m.ColumnQueryAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ColumnQueryAliases[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIngestionAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnIngestionAliases == nil {
				m.ColumnIngestionAliases = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetadata
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetadata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetadata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ColumnIngestionAliases[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTableOP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTableOP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTableOP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Src = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateRootOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpdateRootOP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &LogEntry_UpdateRootOp{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDatabaseOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateDabaseOP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &LogEntry_CreateDatabaseOp{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDatabaseOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpdateDabaseOP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &LogEntry_UpdateDatabaseOp{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletaDatabseOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteDabaseOP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &LogEntry_DeletaDatabseOp{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTableOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateTableOP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &LogEntry_CreateTableOp{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTableOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpdateTableOP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &LogEntry_UpdateTableOp{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteTableOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteTableOP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &LogEntry_DeleteTableOp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddLogEntryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddLogEntryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddLogEntryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, LogEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddLogEntryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddLogEntryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddLogEntryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, LogEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetadata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetadata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetadata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetadata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetadata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetadata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetadata = fmt.Errorf("proto: unexpected end of group")
)
