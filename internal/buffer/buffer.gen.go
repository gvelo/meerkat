// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: buffer.gen.go.tmpl

// Copyright 2020 The Meerkat Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package buffer

// Int

type IntBuffer struct {
	buf      []int
	nulls    []bool
	nullable bool
}

func NewIntBuffer(nullable bool, capacity int) *IntBuffer {

	b := &IntBuffer{
		buf:      make([]int, 0, capacity),
		nullable: nullable,
	}

	if nullable {
		b.nulls = make([]bool, 0, capacity)
	}

	return b

}

func (b *IntBuffer) Len() int {
	return len(b.buf)
}

func (b *IntBuffer) Size() int {
	// TODO(gvelo) add null space.
	return len(b.buf) * 8
}

func (b *IntBuffer) Nulls() []bool {
	return b.nulls
}

func (b *IntBuffer) AppendNull() {

	if !b.nullable {
		panic("not nullable")
	}

	b.nulls = append(b.nulls, true)
	b.buf = append(b.buf, 0)

}

func (b *IntBuffer) Nullable() bool {
	return b.nullable
}

func (b *IntBuffer) Values() []int {
	return b.buf
}

func (b *IntBuffer) AppendInt(v int) {

	b.buf = append(b.buf, v)

	if b.nullable {
		b.nulls = append(b.nulls, false)
	}

}

func (b *IntBuffer) Append(v interface{}) {
	b.AppendInt(v.(int))
}

func (b *IntBuffer) AppendIntBuffer(s *IntBuffer) {

	if b.nullable != s.nullable {
		panic("schema mutation on ingestion not supported yet")
	}

	b.buf = append(b.buf, s.buf...)

	if b.nullable {
		b.nulls = append(b.nulls, s.nulls...)
	}

}

func (b *IntBuffer) AppendBuffer(buf interface{}) {
	b.AppendIntBuffer(buf.(*IntBuffer))
}

// Uint

type UintBuffer struct {
	buf      []uint
	nulls    []bool
	nullable bool
}

func NewUintBuffer(nullable bool, capacity int) *UintBuffer {

	b := &UintBuffer{
		buf:      make([]uint, 0, capacity),
		nullable: nullable,
	}

	if nullable {
		b.nulls = make([]bool, 0, capacity)
	}

	return b

}

func (b *UintBuffer) Len() int {
	return len(b.buf)
}

func (b *UintBuffer) Size() int {
	// TODO(gvelo) add null space.
	return len(b.buf) * 8
}

func (b *UintBuffer) Nulls() []bool {
	return b.nulls
}

func (b *UintBuffer) AppendNull() {

	if !b.nullable {
		panic("not nullable")
	}

	b.nulls = append(b.nulls, true)
	b.buf = append(b.buf, 0)

}

func (b *UintBuffer) Nullable() bool {
	return b.nullable
}

func (b *UintBuffer) Values() []uint {
	return b.buf
}

func (b *UintBuffer) AppendUint(v uint) {

	b.buf = append(b.buf, v)

	if b.nullable {
		b.nulls = append(b.nulls, false)
	}

}

func (b *UintBuffer) Append(v interface{}) {
	b.AppendUint(v.(uint))
}

func (b *UintBuffer) AppendUintBuffer(s *UintBuffer) {

	if b.nullable != s.nullable {
		panic("schema mutation on ingestion not supported yet")
	}

	b.buf = append(b.buf, s.buf...)

	if b.nullable {
		b.nulls = append(b.nulls, s.nulls...)
	}

}

func (b *UintBuffer) AppendBuffer(buf interface{}) {
	b.AppendUintBuffer(buf.(*UintBuffer))
}

// Float

type FloatBuffer struct {
	buf      []float64
	nulls    []bool
	nullable bool
}

func NewFloatBuffer(nullable bool, capacity int) *FloatBuffer {

	b := &FloatBuffer{
		buf:      make([]float64, 0, capacity),
		nullable: nullable,
	}

	if nullable {
		b.nulls = make([]bool, 0, capacity)
	}

	return b

}

func (b *FloatBuffer) Len() int {
	return len(b.buf)
}

func (b *FloatBuffer) Size() int {
	// TODO(gvelo) add null space.
	return len(b.buf) * 8
}

func (b *FloatBuffer) Nulls() []bool {
	return b.nulls
}

func (b *FloatBuffer) AppendNull() {

	if !b.nullable {
		panic("not nullable")
	}

	b.nulls = append(b.nulls, true)
	b.buf = append(b.buf, 0)

}

func (b *FloatBuffer) Nullable() bool {
	return b.nullable
}

func (b *FloatBuffer) Values() []float64 {
	return b.buf
}

func (b *FloatBuffer) AppendFloat(v float64) {

	b.buf = append(b.buf, v)

	if b.nullable {
		b.nulls = append(b.nulls, false)
	}

}

func (b *FloatBuffer) Append(v interface{}) {
	b.AppendFloat(v.(float64))
}

func (b *FloatBuffer) AppendFloatBuffer(s *FloatBuffer) {

	if b.nullable != s.nullable {
		panic("schema mutation on ingestion not supported yet")
	}

	b.buf = append(b.buf, s.buf...)

	if b.nullable {
		b.nulls = append(b.nulls, s.nulls...)
	}

}

func (b *FloatBuffer) AppendBuffer(buf interface{}) {
	b.AppendFloatBuffer(buf.(*FloatBuffer))
}

// Bool

type BoolBuffer struct {
	buf      []bool
	nulls    []bool
	nullable bool
}

func NewBoolBuffer(nullable bool, capacity int) *BoolBuffer {

	b := &BoolBuffer{
		buf:      make([]bool, 0, capacity),
		nullable: nullable,
	}

	if nullable {
		b.nulls = make([]bool, 0, capacity)
	}

	return b

}

func (b *BoolBuffer) Len() int {
	return len(b.buf)
}

func (b *BoolBuffer) Size() int {
	// TODO(gvelo) add null space.
	return len(b.buf) * 1
}

func (b *BoolBuffer) Nulls() []bool {
	return b.nulls
}

func (b *BoolBuffer) AppendNull() {

	if !b.nullable {
		panic("not nullable")
	}

	b.nulls = append(b.nulls, true)
	b.buf = append(b.buf, false)

}

func (b *BoolBuffer) Nullable() bool {
	return b.nullable
}

func (b *BoolBuffer) Values() []bool {
	return b.buf
}

func (b *BoolBuffer) AppendBool(v bool) {

	b.buf = append(b.buf, v)

	if b.nullable {
		b.nulls = append(b.nulls, false)
	}

}

func (b *BoolBuffer) Append(v interface{}) {
	b.AppendBool(v.(bool))
}

func (b *BoolBuffer) AppendBoolBuffer(s *BoolBuffer) {

	if b.nullable != s.nullable {
		panic("schema mutation on ingestion not supported yet")
	}

	b.buf = append(b.buf, s.buf...)

	if b.nullable {
		b.nulls = append(b.nulls, s.nulls...)
	}

}

func (b *BoolBuffer) AppendBuffer(buf interface{}) {
	b.AppendBoolBuffer(buf.(*BoolBuffer))
}
