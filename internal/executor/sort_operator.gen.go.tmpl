// Copyright 2020 The Meerkat Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package executor

    import (
    	"meerkat/internal/storage/vector"
    )

{{range .}}

func (op *SortOperator) create{{.Name}}Vector(v vector.{{.Name}}Vector) vector.{{.Name}}Vector {
	var rv vector.{{.Name}}Vector
	total := 0
	if v.HasNulls() {
		rv = vector.DefaultVectorPool().Get{{.Name}}Vector()
		for i := op.batchProc * op.ctx.Sz(); i < len(op.order); i++ {
			rv.Append{{.Name}}(v.Values()[op.order[i]])
			if v.IsValid(op.order[i]) {
				rv.SetValid(i)
			} else {
				rv.SetInvalid(i)
			}
			total++
		}
	} else {
		rv = vector.DefaultVectorPool().GetNotNullable{{.Name}}Vector()
		for i := op.batchProc * op.ctx.Sz(); i < len(op.order); i++ {
			rv.Append{{.Name}}(v.Values()[op.order[i]])
			total++
		}
	}
	return rv
}



func part{{.Name}}Vec(colVec vector.{{.Name}}Vector, order []int, b []bool) {
	var lastVal {{.name}}
	var lastValNull bool
	b[0] = true
	if colVec.HasNulls() {
		for outputIdx, checkIdx := range order {
			null := !colVec.IsValid(checkIdx)
			if null {
				if !lastValNull {
					// The current value is null while the previous was not.
					b[outputIdx] = true
				}
			} else {
				v := colVec.Get(checkIdx)
				if lastValNull {
					// The previous value was null while the current is not.
					b[outputIdx] = true
				} else {
					// Neither value is null, so we must compare.
					var unique bool

					{
						var cmpResult int

						{
							a, b := int64(v), int64(lastVal)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						unique = cmpResult != 0
					}

					b[outputIdx] = b[outputIdx] || unique
				}
				lastVal = v
			}
			lastValNull = null
		}
	} else {
		for outputIdx, checkIdx := range order {
			v := colVec.Get(checkIdx)
			var unique bool

			{
				var cmpResult int

				{
					a, b := int64(v), int64(lastVal)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				unique = cmpResult != 0
			}

			b[outputIdx] = b[outputIdx] || unique
			lastVal = v
		}
	}
}


{{ end }}